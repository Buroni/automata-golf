/**
 * Utility functions for parsing. Transforms the Jison rule output from a stream
 * of tokens to a grouped list of transitions.
 *
 * Below shows the parsing process starting from the Jison token stream for the following program:
 *
 * (s0) -f> s1:
 * s0 -g> s2;
 *
 * *************** Initial Jison output ***************
 *
 * Line 1:
 * [
 *   { type: 'state', name: 's0', initial: true },
 *   { type: 'transition', direction: 'r', name: 'f,' },
 *   { type: 'state', name: 's1' }
 * ]
 *
 * Line 2:
 * [
 *   { type: 'state', name: 's0' },
 *   { type: 'transition', direction: 'r', name: 'g,' },
 *   { type: 'state', name: 's2' }
 * ]
 *
 * *************** Transition objects generated by `unpackRuleStmt` ***************
 *
 * Line 1:
 * { s0: { 'f,': [Function (anonymous)], '@@nextState_f,': 's1' } }
 *
 * Line 2:
 * { s0: { 'g,': [Function (anonymous)], '@@nextState_g,': 's2' } }
 *
 * *************** Transformed output after `utils.mergeRules` ***************
 *
 * {
 *   s0: {
 *     'f,': [Function],
 *     '@@nextState_f,': 's1',
 *     'g,': [Function],
 *     '@@nextState_g,': 's2'
 *   }
 * }
 */

const { ParseError, isMetaProperty } = require("../utils.js");

function mergeRuleToTarget(rule, state, target) {
    /**
     * For each transition at the given state, assign it to the target object.
     */
    for (const transitionName in rule[state]) {
        if (!target[state][transitionName]) {
            target[state][transitionName] = [];
        }
        if (Array.isArray(rule[state][transitionName]))
            target[state][transitionName].push(...rule[state][transitionName]);
        else
            target[state][transitionName].push(rule[state][transitionName]);
    }
}

function mergeTransitions(...rules) {
    /**
     * Merges array of transition rules for multiple path statements into a single object.
     *
     * For example
     * [
     *    { s0: { 'f,': [Function], '@@nextState_f,': 's1' } },
     *    { s0: { 'g,': [Function], '@@nextState_g,': 's2' } },
     * ]
     *
     * Becomes
     * {
     *   s0: {
     *     'f,': [Function],
     *     '@@nextState_f,': 's1',
     *     'g,': [Function],
     *     '@@nextState_g,': 's2'
     *   }
     * }
     */
    const target = {};

    for (const rule of rules) {
        for (const state in rule) {
            if (!target[state]) {
                target[state] = {};
            }
            mergeRuleToTarget(rule, state, target);
        }
    }
    return target;
}

function TransitionBuilder() {
    /**
     * Builds an object of executable transition functions, pushing a new transition
     * for each `(state, transition, nextState)` tuple given to the `addTransition` method.
     */
    this.transitions = {};

    this._getTransitionFunction = function(transition, nextState) {
        const [transitionName, stackTransition] = transition.name.split(",");
        let fnStr = `this.state = '${nextState.name}';\n`;
        if (transitionName !== "_") {
            fnStr += "this.input.shift();\n";
        }
        if (stackTransition) {
            fnStr += "this.stack.pop();\n"
        }
        if (transition.stackVal) {
            fnStr += `this.stack.push(...${JSON.stringify(transition.stackVal.split(","))});`;
        }
        return new Function(fnStr);
    }

    this.addTransition = function (state, transition, nextState) {
        const fn = this._getTransitionFunction(transition, nextState);
        const { name } = state;

        const transitionObj = {
            fn,
            // @@ values are used for generating source code, as the needed
            // value is hidden inside the function closure during code generation.
            [`@@nextState_${transition.name}`]: nextState.name,
        };

        if (transition.stackVal) {
            transitionObj[`@@stackVal_${transition.name}`] = transition.stackVal;
        }

        if (!this.transitions[name]) {
            this.transitions[name] = [];
        }

        if (!this.transitions[name][transition.name]) {
            this.transitions[name][transition.name] = [];
        }

        this.transitions[name][transition.name].push(transitionObj);
    }
}

function unpackRuleStmt(ruleArr) {
    /**
     * Converts rule statement into an array of transitions.
     */
    const builder = new TransitionBuilder();

    // Use statesFound instead of checking `Object.keys(transitions)` as some states
    // might only be defined as destination nodes (e.g. `source -f> destination`)
    const statesFound = [];
    const transitionsFound = [];
    const acceptStates = [];

    const pushFound = (arr, name) => {
        if (!arr.includes(name) && !isMetaProperty(name)) {
            arr.push(name);
        }
    };

    ruleArr.forEach((state, i) => {
        if (state.type === "state" && i !== ruleArr.length - 1) {
            const transition = ruleArr[i + 1];
            const nextState = ruleArr[i + 2];

            pushFound(statesFound, state.name);
            pushFound(statesFound, nextState.name);
            pushFound(transitionsFound, transition.name.split(",")[0]);

            state.accept && pushFound(acceptStates, state.name);
            nextState.accept && pushFound(acceptStates, nextState.name);

            switch (transition.direction) {
                case "r":
                    builder.addTransition(state, transition, nextState);
                    break;
                case "l":
                    builder.addTransition(nextState, transition, state);
                    break;
                case "lr":
                    builder.addTransition(state, transition, nextState);
                    builder.addTransition(nextState, transition, state);
                    break;
                default:
                    break;
            }
        }
    });

    const initialState = ruleArr.find(r => r.initial);

    return {
        initial: initialState?.name || false,
        transitions: builder.transitions,
        statesFound,
        transitionsFound,
        acceptStates,
    };
}

function addRegexToTransitions(transitions, statesFound, regexp, regexState) {
    // TODO - update for NPDAs
    /**
     * Search for states matching given regex pattern, and add th transitions for that regex state
     * if the state matches.
     */
    for (const state of statesFound) {
        for (const transitionName in regexState) {
            if (!transitions[state]) {
                transitions[state] = {};
            }
            if (state.match(regexp)) {
                if (!transitions[state][transitionName]) {
                    transitions[state][transitionName] = [];
                }
                transitions[state][transitionName].push(...regexState[transitionName]);
            }
        }
    }
}

function applyRegex(transitions, statesFound) {
    /**
     * Adds new transitions matching given regex. For example
     *
     * (s0) -f> s1;
     * s0 -g> s2;
     * /s[0-9]/ -foo> bar;
     *
     * Adds the following transitions:
     * s0 -foo> bar;
     * s1 -foo> bar;
     * s2 -foo> bar;
     */
    for (const state in transitions) {
        const [, regex] = state.split("@@regexp:")
        if (!regex) {
            continue;
        }
        const regexState = transitions[state];
        const regexp = new RegExp(regex);
        // We don't want `/regexp/` to be treated as a literal state
        delete transitions[state];
        addRegexToTransitions(transitions, statesFound, regexp, regexState);
    }
}

function mergeRules(rules) {
    /**
     * Merges array of processed rule objects into a single object
     */
    const flatUnique = (arr, prop) => [...new Set(arr.map(r => r[prop]).flat())];
    const transitions = mergeTransitions({}, ...rules.map(r => r.transitions));
    const statesFound = flatUnique(rules, "statesFound");
    const acceptStates = flatUnique(rules, "acceptStates");
    const transitionsFound = flatUnique(rules, "transitionsFound");

    applyRegex(transitions, statesFound);

    const initial = rules.find(r => r.initial)?.initial;
    if (!initial) {
        throw new ParseError(
            "Initial state not found; set initial state by wrapping in parenthesis, e.g. `(s0) -f> s1`"
        );
    }

    return {
        initial,
        transitions,
        transitionsFound,
        acceptStates,
    }
}

module.exports = {unpackRuleStmt, mergeRules};