/**
 * Utility functions for parsing. Transforms the Jison rule output from a stream
 * of tokens to a grouped list of transitions.
 *
 * Below shows the parsing process starting from the Jison token stream for the following program:
 *
 * (s0) -f> s1:
 * s0 -g> s2;
 *
 * *************** Initial Jison output ***************
 *
 * Line 1:
 * [
 *   { type: 'state', name: 's0', initial: true },
 *   { type: 'transition', direction: 'r', name: 'f:' },
 *   { type: 'state', name: 's1' }
 * ]
 *
 * Line 2:
 * [
 *   { type: 'state', name: 's0' },
 *   { type: 'transition', direction: 'r', name: 'g:' },
 *   { type: 'state', name: 's2' }
 * ]
 *
 * *************** Transition objects generated by `unpackRuleStmt` ***************
 *
 * Line 1:
 * { s0: { 'f,': [Function (anonymous)], '@@nextState_f,': 's1' } }
 *
 * Line 2:
 * { s0: { 'g,': [Function (anonymous)], '@@nextState_g,': 's2' } }
 *
 * *************** Transformed output after `utils.mergeRules` ***************
 *
 * {
 *   s0: {
 *     'f,': [Function],
 *     '@@nextState_f,': 's1',
 *     'g,': [Function],
 *     '@@nextState_g,': 's2'
 *   }
 * }
 */

const { ParseError, isMetaProperty } = require("../utils.js");
const { makeTransitionFunction } = require("../generator/serialize.js");

function mergeTransitions(...rules) {
    /**
     * Merges array of transition rules for multiple path statements into a single object.
     *
     * For example
     * [
     *    { s0: { 'f,': [Function], '@@nextState_f,': 's1' } },
     *    { s0: { 'g,': [Function], '@@nextState_g,': 's2' } },
     * ]
     *
     * Becomes
     * {
     *   s0: {
     *     'f,': [Function],
     *     '@@nextState_f,': 's1',
     *     'g,': [Function],
     *     '@@nextState_g,': 's2'
     *   }
     * }
     */
    const target = {};

    for (const rule of rules) {
        for (const state in rule) {
            if (!target[state]) {
                target[state] = [];
            }
            target[state].push(...rule[state]);
        }
    }

    return target;
}

function TransitionBuilder() {
    /**
     * Builds an object of executable transition functions, pushing a new transition
     * for each `(state, transition, nextState)` tuple given to the `addTransition` method.
     */
    this.transitions = [];

    this.addTransition = function (state, transition, nextState) {
        const fn = makeTransitionFunction(transition, nextState.name);

        const transitionObj = {
            fn,
            // @@ values are used for generating source code, as the needed
            // value is hidden inside the function closure during code generation.
            [`@@nextState_${transition.input}`]: nextState.name,
        };

        if (transition.stacks?.length) {
            transitionObj[`@@stackVal_${transition.input}`] =
                transition.stacks[0].write;
        }

        if (!this.transitions[state.name]) {
            this.transitions[state.name] = [];
        }

        this.transitions[state.name].push({
            filter: {
                state: state.name,
                input: transition.input,
                stackValues: transition.stacks?.map((s) => s.read) || [],
            },
            ...transitionObj,
        });
    };
}

function unpackRuleStmt(ruleArr) {
    /**
     * Converts rule statement into an array of transitions.
     */
    const builder = new TransitionBuilder();

    // Use statesFound instead of checking `Object.keys(transitions)` as some states
    // might only be defined as destination nodes (e.g. `source -f> destination`)
    const statesFound = [];
    const transitionsFound = [];
    const acceptStates = [];

    const pushFound = (arr, name) => {
        if (!arr.includes(name) && !isMetaProperty(name)) {
            arr.push(name);
        }
    };

    ruleArr.forEach((state, i) => {
        if (state.type === "state" && i !== ruleArr.length - 1) {
            // TODO - handle 1-item array in jison parser;
            // `transitionItem` may be a kvp object or array
            const transitionItem = ruleArr[i + 1];
            const transitions = Array.isArray(transitionItem)
                ? transitionItem
                : [transitionItem];
            const nextState = ruleArr[i + 2];

            pushFound(statesFound, state.name);
            pushFound(statesFound, nextState.name);

            state.accept && pushFound(acceptStates, state.name);
            nextState.accept && pushFound(acceptStates, nextState.name);

            for (const transition of transitions) {
                pushFound(transitionsFound, transition.input);

                switch (transition.direction) {
                    case "r":
                        builder.addTransition(state, transition, nextState);
                        break;
                    case "l":
                        builder.addTransition(nextState, transition, state);
                        break;
                    case "lr":
                        builder.addTransition(state, transition, nextState);
                        builder.addTransition(nextState, transition, state);
                        break;
                    default:
                        break;
                }
            }
        }
    });

    const initialState = ruleArr.find((r) => r.initial);

    return {
        initial: initialState?.name || false,
        transitions: builder.transitions,
        statesFound,
        transitionsFound,
        acceptStates,
    };
}

function addRegexToTransitions(transitions, statesFound, regexp, regexState) {
    /**
     * Search for states matching given regex pattern, and add th transitions for that regex state
     * if the state matches.
     */
    for (const state of statesFound) {
        for (const transitionName in regexState) {
            if (!transitions[state]) {
                transitions[state] = {};
            }
            if (state.match(regexp)) {
                if (!transitions[state][transitionName]) {
                    transitions[state][transitionName] = [];
                }
                transitions[state][transitionName].push(
                    ...regexState[transitionName]
                );
            }
        }
    }
}

function applyRegex(transitions, statesFound) {
    /**
     * Adds new transitions matching given regex. For example
     *
     * (s0) -f> s1;
     * s0 -g> s2;
     * /s[0-9]/ -foo> bar;
     *
     * Adds the following transitions:
     * s0 -foo> bar;
     * s1 -foo> bar;
     * s2 -foo> bar;
     */
    for (const state in transitions) {
        const [, regex] = state.split("@@regexp:");
        if (!regex) {
            continue;
        }
        const regexState = transitions[state];
        const regexp = new RegExp(regex);
        // We don't want `/regexp/` to be treated as a literal state
        delete transitions[state];
        addRegexToTransitions(transitions, statesFound, regexp, regexState);
    }
}

function mergeRules(rules) {
    /**
     * Merges array of processed rule objects into a single object
     */
    const flatUnique = (arr, prop) => [
        ...new Set(arr.map((r) => r[prop]).flat()),
    ];
    const transitions = mergeTransitions(...rules.map((r) => r.transitions));
    const statesFound = flatUnique(rules, "statesFound");
    const acceptStates = flatUnique(rules, "acceptStates");
    const transitionsFound = flatUnique(rules, "transitionsFound");

    applyRegex(transitions, statesFound);

    const initial = rules.find((r) => r.initial)?.initial;
    if (!initial) {
        throw new ParseError(
            "Initial state not found; set initial state by prefixing with `.`, e.g. `.s0 -f> s1`"
        );
    }

    return {
        initial,
        transitions,
        transitionsFound,
        acceptStates,
    };
}

module.exports = { unpackRuleStmt, mergeRules };
